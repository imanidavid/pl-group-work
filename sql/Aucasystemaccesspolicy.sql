CREATE TABLE data_records (
    id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    performed_by  VARCHAR2(255),
    action_type   VARCHAR2(255),
    payload       CLOB CHECK (payload IS JSON),
    created_at    TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP
);
CREATE TABLE access_errors (
    id               NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    attempted_by     VARCHAR2(255) NOT NULL,
    attempted_at     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    attempted_action VARCHAR2(20) NOT NULL,   -- 'INSERT' / 'UPDATE' / 'DELETE'
    table_name       VARCHAR2(128) NOT NULL,
    record_id        NUMBER,
    details          CLOB
);
-- from app session (PL/SQL / JDBC) set like this:
BEGIN
  DBMS_SESSION.SET_IDENTIFIER('app_user_123');  -- or use DBMS_SESSION.SET_CONTEXT
END;
/
CREATE OR REPLACE PACKAGE audit_pkg AS
  PROCEDURE log_violation_autonomous(
    p_attempted_by     IN VARCHAR2,
    p_attempted_action IN VARCHAR2,
    p_table_name       IN VARCHAR2,
    p_record_id        IN NUMBER,
    p_details          IN CLOB
  );
END audit_pkg;
/

CREATE OR REPLACE PACKAGE BODY audit_pkg AS

  PROCEDURE log_violation_autonomous(
    p_attempted_by     IN VARCHAR2,
    p_attempted_action IN VARCHAR2,
    p_table_name       IN VARCHAR2,
    p_record_id        IN NUMBER,
    p_details          IN CLOB
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO access_errors (
      attempted_by, attempted_at, attempted_action, table_name, record_id, details
    ) VALUES (
      p_attempted_by,
      SYSTIMESTAMP AT TIME ZONE 'UTC',  -- optional: store in UTC; adjust if you prefer local tz
      p_attempted_action,
      p_table_name,
      p_record_id,
      p_details
    );

    COMMIT; -- required for autonomous transaction to persist independently
  EXCEPTION
    WHEN OTHERS THEN
      -- If logging itself fails, swallow the exception to avoid masking the root cause,
      -- but optionally you can raise or write to OS log via UTL_FILE if available.
      NULL;
  END log_violation_autonomous;

END audit_pkg;
/
CREATE OR REPLACE TRIGGER trg_enforce_access_time
BEFORE INSERT OR UPDATE OR DELETE ON data_records
FOR EACH ROW
DECLARE
  v_local_ts      TIMESTAMP WITH TIME ZONE;
  v_day_abbrev    VARCHAR2(3);
  v_time_hm       VARCHAR2(5);  -- 'HH24:MI'
  v_attempted_by  VARCHAR2(255);
  v_rec_id        NUMBER;
  v_details       CLOB;
BEGIN
  -- get current timestamp in Africa/Kigali
  v_local_ts := SYSTIMESTAMP AT TIME ZONE 'Africa/Kigali';

  -- day abbreviation in English (MON, TUE, ... SAT, SUN)
  v_day_abbrev := UPPER(TO_CHAR(v_local_ts, 'DY', 'NLS_DATE_LANGUAGE = ENGLISH'));

  -- time as HH24:MI string (works for lexicographic comparison)
  v_time_hm := TO_CHAR(v_local_ts, 'HH24:MI');

  -- determine actor (app should set CLIENT_IDENTIFIER; fallback to SESSION_USER)
  v_attempted_by := NVL(SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER'),
                        SYS_CONTEXT('USERENV','SESSION_USER'));

  -- determine record id (if available)
  IF INSERTING THEN
    v_rec_id := NULL;                 -- id not generated yet (if using identity)
  ELSIF UPDATING THEN
    v_rec_id := NVL(:NEW.id, :OLD.id);
  ELSIF DELETING THEN
    v_rec_id := :OLD.id;
  END IF;

  -- Build details for logging
  v_details := 'Local timestamp: ' || TO_CHAR(v_local_ts, 'YYYY-MM-DD HH24:MI:SS TZR') ||
               '; Day: ' || v_day_abbrev || '; Local time: ' || v_time_hm ||
               '; Operation: ' || CASE WHEN INSERTING THEN 'INSERT'
                                        WHEN UPDATING THEN 'UPDATE'
                                        WHEN DELETING THEN 'DELETE' END;

  -- Business rule check:
  -- Allowed only Mon-Fri and between 08:00 and 17:00 inclusive (Africa/Kigali)
  IF (v_day_abbrev IN ('SAT','SUN')) OR (v_time_hm < '08:00') OR (v_time_hm > '17:00') THEN

    -- Log the attempted violation using autonomous procedure (guaranteed commit)
    audit_pkg.log_violation_autonomous(
      p_attempted_by     => v_attempted_by,
      p_attempted_action => CASE WHEN INSERTING THEN 'INSERT' WHEN UPDATING THEN 'UPDATE' ELSE 'DELETE' END,
      p_table_name       => 'DATA_RECORDS',
      p_record_id        => v_rec_id,
      p_details          => v_details
    );

    -- Block the operation by raising an application error
    RAISE_APPLICATION_ERROR(-20001,
      'Access denied: operations allowed Monday–Friday 08:00–17:00 (Africa/Kigali). Attempt logged.');
  END IF;

  -- If allowed, simply continue (no-op). RETURNING NEW/OLD is implicit in row trigger.

END trg_enforce_access_time;
/
CREATE OR REPLACE TRIGGER trg_audit_successful_ops
AFTER INSERT OR UPDATE OR DELETE ON data_records
FOR EACH ROW
DECLARE
  v_actor VARCHAR2(255) := NVL(SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV','SESSION_USER'));
  v_action VARCHAR2(20) := CASE WHEN INSERTING THEN 'INSERT' WHEN UPDATING THEN 'UPDATE' ELSE 'DELETE' END;
BEGIN
  -- Example: insert into a separate audit table (not access_errors) for successful operations.
  -- This is optional and will only run for operations that completed (i.e., enforcement didn't block).
  NULL;
END trg_audit_successful_ops;
/
BEGIN
  DBMS_SESSION.SET_IDENTIFIER('iris');  -- or DBMS_SESSION.SET_CONTEXT for a custom namespace
END;
/
INSERT INTO data_records (performed_by, action_type, payload)
VALUES ('iris', 'CREATE', '{"foo":"bar"}');
SELECT id, attempted_by, attempted_at, attempted_action, table_name, record_id, dbms_lob.substr(details, 4000, 1) details
FROM access_errors
ORDER BY attempted_at DESC;
INSERT INTO data_records (performed_by, action_type, payload)
VALUES ('iris', 'CREATE', '{"foo":"bar"}');
